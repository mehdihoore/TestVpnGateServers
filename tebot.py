import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Updater, MessageHandler, filters, CommandHandler, CallbackContext
import requests as rs
from telegram.ext import JobQueue
import pandas as pd
from bs4 import BeautifulSoup
import os
import sys
import jdatetime
import datetime
import pytz
from time import sleep
import textwrap
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)






def get_persian_date_time():
    # Get the current date and time in Persian (Jalali) calendar
    now = datetime.datetime.now()

    hour = now.hour + 3
    minute = now.minute + 30

    if minute >= 60:
        hour += 1
        minute -= 60

    if hour >= 24:
        hour -= 24
    nowp = jdatetime.datetime.now()
    nowt = datetime.datetime(now.year, now.month, now.day, hour, minute, now.second, now.microsecond)
    persian_date_time = nowp.strftime("%A, %d %B %Y ") + nowt.strftime("%H:%M:%S")
    return persian_date_time
# SSTP function (same as before)
def get_sstp_data():
    url = 'https://vpngate.hore.workers.dev/'

    response = rs.get(url)
    soup = BeautifulSoup(response.text, "html.parser")
    tbody = soup.find("table")

    if tbody:
        table_data = []

        for tr in tbody.find_all("tr"):
            row_data = [td.get_text(strip=True) for td in tr.find_all("td")]
            table_data.append(row_data)

        df = pd.DataFrame(table_data)

        column_names = {
            0: 'Country',
            1: 'DDNS Hostname / IP Address (ISP Hostname)',
            2: 'VPN Server Name',
            3: 'Ping Time',
            4: 'Speed',
            5: 'Country Long',
            6: 'Privacy',
            7: 'SSTP Hostname',
            8: 'SSTP Description',
            9: 'OpenVPN Configuration'

        }
        df.rename(columns=column_names, inplace=True)
        new_df = pd.DataFrame({
        'Country': df['Country'],
        'DDNS': df['DDNS Hostname / IP Address (ISP Hostname)'],
        'Ping Time': df['Ping Time'],
        'SSTP Hostname': df['SSTP Hostname']
    })
        # perform the string replacements on column 'sstp'
        new_df['SSTP Hostname'] = new_df['SSTP Hostname'].str.replace('MS-SSTPConnect guideSSTP Hostname :', '')
        new_df['SSTP Hostname'] = new_df['SSTP Hostname'].str.replace('MS-SSTPWindows Vista,7, 8, RTNo client required', '')
        new_df['Ping Time'] = new_df['Ping Time'].str.extract(r'Ping:\s*(\d+)\s*ms')
        # Filtering out rows where the value in the first column is "Country(Physical location)"
        new_df = new_df[new_df.iloc[:, 0] != "Country(Physical location)"]

        # Resetting the index if needed
        new_df.reset_index(drop=True, inplace=True)
        new_df['Ping Time'] = new_df['Ping Time'].fillna('666').astype(int)
        sorted_df = new_df.sort_values(by=['Ping Time'], ascending=True)
        sorted_df.reset_index(drop=True, inplace=True)
        sorted_df['sstp_link'] = '<a href="' + sorted_df['SSTP Hostname'] + '">' + sorted_df['SSTP Hostname'] + '</a>'
        sorted_df.to_html('sstp.html', escape=False, index=False)
        print(sorted_df)
        # Get the current Persian date and time
        persian_now = get_persian_date_time()
        # Add filter dropdown for the 'country' column
        country_filter = sorted(sorted_df['Country'].unique().tolist())
        country_filter.insert(0, 'All Countries')

        # Generate the HTML table with filtering capabilities
        html_table = sorted_df.to_html(index=False, escape=False, classes='dataframe', na_rep='')

        # Remove the original header row generated by Pandas
        html_table = html_table.replace('<thead>\n<tr>', '<thead>\n<tr><th>Country</th><th>Ping Time</th><th>SSTP Link</th></tr>\n')

        # Insert the JavaScript for filtering into the HTML content
        js_script = f'''
        <script>
        function filterTable() {{
          const inputCountry = document.getElementById('filterCountry').value.toLowerCase();
          const rows = document.querySelectorAll('tbody tr');

          for (let i = 0; i < rows.length; i++) {{
            const row = rows[i];
            const country = row.children[0].innerText.toLowerCase();

            if (inputCountry === 'all countries' || country.includes(inputCountry)) {{
              row.style.display = 'table-row';
            }} else {{
              row.style.display = 'none';
            }}
          }}
        }}
        </script>
        '''

        # Generate the final HTML content with the filtering functionality
        html_content = f'''
        <html>
        <head>
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <style>
              /* Add some basic CSS styles to make the table responsive */
              table {{
                width: 100%;
                border-collapse: collapse;
              }}

              th, td {{
                border: 1px solid #dddddd;
                /* Light gray border between cells */
                padding: 8px;
                text-align: left;
                /* Align table cell text to the left */
                min-width: 1px;
                /* Set minimum width to 1px */
                max-width: 100%;
                /* Set maximum width to 100% */
                overflow: hidden;
                /* Hide any overflowing content */
                white-space: nowrap;
                /* Prevent text from wrapping */
              }}

              /* Apply styles for the table header */
              thead th {{
                background-color: #f2f2f2;
                /* Light gray background color */
                color: #333333;
                /* Dark gray text color */
                font-weight: bold;
                /* Bold font weight for header text */
                text-align: center;
                /* Center header text */
              }}

              /* Apply custom font to the table */
              table {{
                font-family: Tahoma, sans-serif;
              }}

              /* Make the table responsive */
              @media screen and (max-width: 200px) {{

                /* For smaller screens, reduce font size and wrap table cells */
                th, td {{
                  font-size: 14px;
                  white-space: wrap;
                }}
              }}
            </style>
        </head>
        <body>
            <h1>SSTP SERVERS @ {persian_now}</h1>
            <select id="filterCountry" onchange="filterTable()">
                {''.join([f'<option value="{country}">{country}</option>' for country in country_filter])}
            </select>
            {js_script}
            {html_table}
        </body>
        </html>
        '''

        # Save the updated HTML content to a new file
        with open('sstp.html', 'w', encoding='utf-8') as file:
            file.write(html_content)

        print("The filtered_sstp.html file with filtering functionality and Persian date and time in the header has been created.")
        return 'sstp.html'



def get_v2ray_data():
    v2ray_links = {
        'Invizible Pro':'https://github.com/Gedsh/InviZible/releases',
        'sabat.ir Help Worker': 'https://fin.sabaat.ir/',
        'sabat.link Help Worker': 'https://f.sabaat.link/',
        'mahdibland Github': 'https://github.com/mahdibland/V2RayAggregator',
        'Bardiafa Github': 'https://github.com/Bardiafa/Free-V2ray-Config/blob/main/Persian-README.md',
        'TelegramBot Github': 'https://github.com/yebekhe/TelegramV2rayCollector',
    }
    if v2ray_links is None:
        v2ray_links = {}

    return v2ray_links

def send_server_list(bot):

    persian_date = get_persian_date_time()

    # Send SSTP document
    channel = bot.get_chat("@SSTPV2RAY")
    bot.send_message(chat_id=channel.id, text=f'{persian_date} ✅')

    bot.send_document(chat_id=channel.id, document=open('sstp.html', 'rb'),
                      caption=f'SSTP Servers - {persian_date}')

    v2ray_links = get_v2ray_data()
    links = [
        'https://link.mehdi-hoore.workers.dev/sub/f.sabaat.link',
        'https://fin.hore.workers.dev/sub/fin.sabaat.ir',
        'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/Eternity',

    'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/Eternity.txt',

    'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/sub/splitted/ssr.txt',

    'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/sub/splitted/ss.txt',

    'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/sub/splitted/trojan.txt',

    'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/sub/splitted/vmess.txt',
        'https://raw.githubusercontent.com/Bardiafa/Free-V2ray-Config/main/Splitted-By-Protocol/vmess.txt',

        'https://raw.githubusercontent.com/yebekhe/V2Hub/main/merged_base64',
        'https://raw.githubusercontent.com/yebekhe/V2Hub/main/Split/Base64/vmess',


      ]
    names = ['Worker .ir' , 'Worker .link', 'mahdibland Eternity',
         'mahdibland Eternity txt', 'mahdibland ssr', 'mahdibland ss',
         'mahdibland trojan', 'mahdibland vmess',
         'Bardiafa vemss',

         'Telegram collector: merged_base64',
         'Telegram collector: Base64_vmess',

         ]

    # Get the latest APK version and download URL

    additional_file_urls = [
        'https://github.com/Gedsh/InviZible/releases/download/v1.9.8-beta/Invizible_Pro__beta_ver.1.9.8.apk',
        'https://github.com/Gedsh/InviZible/releases/download/v1.9.8-beta/Invizible_Pro__beta_ver.1.9.8_arm64.apk'
    ]
    additional_file_names = ['Invizible_Pro__beta_ver.1.9.8.apk',
        'Invizible_Pro__beta_ver.1.9.8_arm64.apk'
    ]


    tt = '''
•	تور به نسخه 4.8.5 به‌روزرسانی شد.
این نسخه شامل بهبودهای امنیتی و عملکردی است.
•	استفاده از SNI سفارشی برای اتصال Tor
 مکانیسمی که به وب‌سایت‌ها اجازه می‌دهد بدانند شما از تور استفاده می‌کنید، بدون اینکه آدرس ای‌پی واقعی شما را فاش کنند.
•	اتصال Tor با TLS fingerprint Chromium
 یک ویژگی امنیتی که نشان می‌دهد در حال اتصال به یک سرور Tor واقعی هستید.
•	پل Tor WebTunnel به‌روزرسانی شد..
Tor WebTunnel یک سرویس تور امکان می‌دهد از Tor در مرورگر وب خود استفاده کنید.
•	خطای ANR در Android 4.4.2 برطرف شد.
 یک خطای سیستمی مربوط به زمانیکه برنامه برای مدت طولانی پاسخ نمی‌دهد.
•	خطای دکمه درخواست پل‌های جدید در موارد نادر برطرف شد.
این دکمه به شما امکان می‌دهد تا پل‌های جدید  را درخواست کنید.

    '''

    wrapped_tt = textwrap.fill(tt, initial_indent="    ", subsequent_indent="    ")
    for url, name in zip(additional_file_urls, additional_file_names):
        try:
            response = rs.get(url)
            with open(name, 'wb') as f:
                f.write(response.content)
            bot.send_document(chat_id=channel.id, document=open(name, 'rb'), caption=f'{persian_date} \n{name}\n {url}\n {tt}')
        except Exception as e:
            print(f"Error sending {name}: {e}")
    count = 0

    for link in links:
        try:
            response = rs.get(link)
            content = response.text
        except rs.exceptions.RequestException as e:
            print(f"Error retrieving {link}: {e}")
            continue

        # Save to file
        with open(f'{link.split("/")[-1]}.txt', 'w') as f:
            try:
                f.write(content)
            except UnicodeEncodeError as e:
                print(f"Error retrieving {link}: {e}")
                continue
        # Send file
        try:
            bot.send_document(chat_id=channel.id, document=open(f'{link.split("/")[-1]}.txt', 'rb'), caption=f'{persian_date} \n{names[count]}\n {link}')
        except Exception as e:
            sleep(60)

        count += 1

    inline_buttons = []

    for name, link in v2ray_links.items():
        inline_buttons.append([InlineKeyboardButton(name, url=link)])
    reply_markup = InlineKeyboardMarkup(inline_buttons)



    bot.send_message(chat_id=channel.id, text=f'{persian_date} ✅', reply_markup=reply_markup)



if __name__ == '__main__':
    updater = Updater(token='6210383014:AAHGwo4q87zwKTjO1WgJWrbjEgx5V-TO8_A', request_kwargs={'read_timeout': 30})

    # Add your handlers here (start_handler, restart_handler, etc.)
    dispatcher = updater.dispatcher
    start_handler = CommandHandler('start', start)

    dispatcher.add_handler(start_handler)
    # Call send_server_list to send the first message immediately
    send_server_list(updater.bot)
    def send_job(context):
        send_server_list(context.bot)
   

    # Retry mechanism
    max_retries = 3
    retries = 0

    while retries < max_retries:
        try:
            updater.start_polling()
        except telegram.error.TimedOut:
            # Retry after a short delay
            time.sleep(5)
            retries += 1
            continue
        else:
            break
    else:
        print("Exceeded maximum retries. Failed to start polling.")

    updater.idle()
