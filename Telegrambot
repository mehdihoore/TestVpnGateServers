import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Updater, MessageHandler, Filters, CommandHandler, CallbackContext
import requests as rs
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Updater, MessageHandler, Filters, CommandHandler, CallbackContext
import requests as rs
import pandas as pd
from bs4 import BeautifulSoup
import os
import sys
import jdatetime
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
def get_persian_date_time():
    # Get the current date and time in Persian (Jalali) calendar
    now = jdatetime.datetime.now()
    persian_date_time = now.strftime("%A, %d %B %Y - %H:%M:%S")
    return persian_date_time
# SSTP function (same as before)
def get_sstp_data():
    etes = rs.get('http://103.201.129.226:14684/en/').text
    soup = BeautifulSoup(etes, "html.parser")
    tbody = soup.find("table")
    if tbody is not None:
        tbody_content = tbody.contents

        # Create a list to store the table data
        table_data = []

        # Loop through the <tr> tags in the <tbody> content and extract the table data
        for tr in tbody_content:
            if tr.name == "tr":
                row_data = []
                for td in tr.children:
                    if td.name == "td":
                        row_data.append(td.text.strip())
                table_data.append(row_data)

            # Create a pandas DataFrame object from the table data
        df = pd.DataFrame(table_data)
        # create a new DataFrame with columns 0, 1, 3, and 7 of the original DataFrame
        new_df = df[[0, 1, 3, 7]].copy()
        # rename column 7 to sstp
        new_df = new_df.rename(columns={7: 'sstp'})
        new_df = new_df.rename(columns={0: 'country'})
        new_df = new_df.rename(columns={1: 'DDNS hostnameIP Address(ISP hostname)'})
        new_df = new_df.rename(columns={3: 'Ping Time'})
        # perform the string replacements on column 'sstp'
        new_df['sstp'] = new_df['sstp'].str.replace('MS-SSTPConnect guideSSTP Hostname :', '')
        new_df['sstp'] = new_df['sstp'].str.replace('MS-SSTPWindows Vista,7, 8, RTNo client required', '')
        # remove any rows with empty values in column 'sstp'
        new_df = new_df[new_df['sstp'].notna() & (new_df['sstp'] != '')]
        # extract the value 'Ping: XX ms' from column 2
        new_df['Ping Time'] = new_df['Ping Time'].str.extract(r'Ping:\s*(\d+)\s*ms')
        new_df = new_df.fillna(666)
        new_df['Ping Time'] = new_df['Ping Time'].astype(int)
        df[7] = df[7].str.replace('MS-SSTPConnect guideSSTP Hostname :', '')
        df[7] = df[7].str.replace('MS-SSTPWindows Vista,7, 8, RTNo client required', '')
        df = df[df[7].notna() & (df[7] != '')]
        # separate the server name and port number in column 'sstp'
        new_df[['server', 'port']] = new_df['sstp'].str.split(':', expand=True)
        # export the resulting DataFrame to an Excel file
        df[7].to_csv('rowsstp.csv', index=False)
        sorted_df = new_df.sort_values(by=['Ping Time'], ascending=True)
        sorted_df.reset_index(drop=True, inplace=True)
        
        sorted_df['sstp_link'] = '<a href="' + sorted_df['sstp'] + '">' + sorted_df['sstp'] + '</a>'
       
        ser = pd.DataFrame(sorted_df[[ 'country','Ping Time','sstp','sstp_link' ]])
        ser.to_html('sstp.html', escape=False, index=False)
        print(sorted_df)
        # Get the current Persian date and time
        persian_now = get_persian_date_time()

        # Recreate the 'sstp_link' column using the 'sstp' column from the existing DataFrame
        ser['sstp_link'] = ser['sstp'].apply(lambda sstp: f'<a href="{sstp}">{sstp}</a>')

        # Add filter dropdown for the 'country' column
        country_filter = sorted(ser['country'].unique().tolist())
        country_filter.insert(0, 'All Countries')

        # Generate the HTML table with filtering capabilities
        html_table = ser.to_html(index=False, escape=False, classes='dataframe', na_rep='')

        # Remove the original header row generated by Pandas
        html_table = html_table.replace('<thead>\n<tr>', '<thead>\n<tr><th>Country</th><th>Ping Time</th><th>SSTP Link</th></tr>\n')

        # Insert the JavaScript for filtering into the HTML content
        js_script = f'''
        <script>
        function filterTable() {{
          const inputCountry = document.getElementById('filterCountry').value.toLowerCase();
          const rows = document.querySelectorAll('tbody tr');

          for (let i = 0; i < rows.length; i++) {{
            const row = rows[i];
            const country = row.children[0].innerText.toLowerCase();

            if (inputCountry === 'all countries' || country.includes(inputCountry)) {{
              row.style.display = 'table-row';
            }} else {{
              row.style.display = 'none';
            }}
          }}
        }}
        </script>
        '''

        # Generate the final HTML content with the filtering functionality
        html_content = f'''
        <html>
        <head>
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <style>
              /* Add some basic CSS styles to make the table responsive */
              table {{
                width: 100%;
                border-collapse: collapse;
              }}

              th, td {{
                border: 1px solid #dddddd;
                /* Light gray border between cells */
                padding: 8px;
                text-align: left;
                /* Align table cell text to the left */
                min-width: 1px;
                /* Set minimum width to 1px */
                max-width: 100%;
                /* Set maximum width to 100% */
                overflow: hidden;
                /* Hide any overflowing content */
                white-space: nowrap;
                /* Prevent text from wrapping */
              }}

              /* Apply styles for the table header */
              thead th {{
                background-color: #f2f2f2;
                /* Light gray background color */
                color: #333333;
                /* Dark gray text color */
                font-weight: bold;
                /* Bold font weight for header text */
                text-align: center;
                /* Center header text */
              }}

              /* Apply custom font to the table */
              table {{
                font-family: Tahoma, sans-serif;
              }}

              /* Make the table responsive */
              @media screen and (max-width: 200px) {{

                /* For smaller screens, reduce font size and wrap table cells */
                th, td {{
                  font-size: 14px;
                  white-space: wrap;
                }}
              }}
            </style>
        </head>
        <body>
            <h1>SSTP SERVERS @ {persian_now}</h1>
            <select id="filterCountry" onchange="filterTable()">
                {''.join([f'<option value="{country}">{country}</option>' for country in country_filter])}
            </select>
            {js_script}
            {html_table}
        </body>
        </html>
        '''

        # Save the updated HTML content to a new file
        with open('sstp.html', 'w', encoding='utf-8') as file:
            file.write(html_content)

        print("The filtered_sstp.html file with filtering functionality and Persian date and time in the header has been created.")
        return 'sstp.html'
            

        # V2ray function (same as before)
def get_v2ray_data():
    v2ray_links = {
        'sabat.ir Workercode': 'https://fin.sabaat.ir/sub/fin.sabaat.ir',
        'sabat.link Workercode': 'https://f.sabaat.link/sub/f.sabaat.link',
        'sabat.ir Help Worker': 'https://fin.sabaat.ir/',
        'sabat.link Help Worker': 'https://f.sabaat.link/',
        'mahdibland Github': 'https://github.com/mahdibland/V2RayAggregator',
        'Bardiafa Github': 'https://github.com/Bardiafa/Free-V2ray-Config/blob/main/Persian-README.md',
        'TelegramBot Github': 'https://github.com/yebekhe/TelegramV2rayCollector',
        'Base64 Mehdibland': 'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/Eternity',
        'Mix Mehdibland': 'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/Eternity.txt',
        'SSR Mehdibland': 'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/sub/splitted/ssr.txt',
        'SHADOWSOCKS Mehdibland':'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/sub/splitted/ssr.txt',
        'trojan Mehdibland':'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/sub/splitted/trojan.txt',
        'vmess Mehdibland':'https://raw.githubusercontent.com/mahdibland/ShadowsocksAggregator/master/sub/splitted/vmess.txt',
    }
    if v2ray_links is None:
        v2ray_links = {}  # or handle the case accordingly

    return v2ray_links

def start(update: Update, context: CallbackContext):
    # Send the initial message with instructions
    initial_message = "Hello! I am your bot. To get started, use the /start command. Here are the instructions:\n\n"
    initial_message += "1. After starting the bot, you will receive a list of SSTP servers in an an HTML file and V2ray options.\n"
    initial_message += "2. You can click on the V2ray options to get the corresponding links.\n"
    initial_message += "Please note that the V2ray links may be subject to change, so always check the latest options.\n"
    context.bot.send_message(chat_id=update.effective_chat.id, text=initial_message)

    # Get SSTP data
    get_sstp_data()

    # Get V2ray links
    v2ray_links = get_v2ray_data()



    # Create inline buttons for V2ray options
    inline_buttons = []
    for name, link in v2ray_links.items():
        inline_buttons.append([InlineKeyboardButton(name, url=link)])

    # Create inline keyboard markup
    reply_markup = InlineKeyboardMarkup(inline_buttons)

    # Send the SSTP data as an HTML file
    context.bot.send_document(chat_id=update.effective_chat.id, document=open('sstp.html', 'rb'), caption="SSTP Servers")

    # Send the V2ray options with inline keyboard
    context.bot.send_message(chat_id=update.effective_chat.id, text="Select V2ray option:", reply_markup=reply_markup)

if __name__ == '__main__':
    # Replace 'YOUR_TOKEN' with your actual Telegram bot token
    updater = Updater(token='TOKEN', request_kwargs={'read_timeout': 30})

    # Add your handlers here (start_handler, restart_handler, etc.)
    dispatcher = updater.dispatcher
    start_handler = CommandHandler('start', start)

    dispatcher.add_handler(start_handler)



    # Retry mechanism
    max_retries = 3
    retries = 0

    while retries < max_retries:
        try:
            updater.start_polling()
        except telegram.error.TimedOut:
            # Retry after a short delay
            time.sleep(5)
            retries += 1
            continue
        else:
            break
    else:
        print("Exceeded maximum retries. Failed to start polling.")

    updater.idle()
